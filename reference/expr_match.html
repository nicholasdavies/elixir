<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Find patterns in expressions — expr_match • elixir</title><!-- katex math --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script><script src="../katex-auto.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Find patterns in expressions — expr_match"><meta name="description" content="Match and extract patterns in an expression or a list of expressions."><meta property="og:description" content="Match and extract patterns in an expression or a list of expressions."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">elixir</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/elixir.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/nicholasdavies/elixir/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Find patterns in expressions</h1>
      <small class="dont-index">Source: <a href="https://github.com/nicholasdavies/elixir/blob/main/R/match.R" class="external-link"><code>R/match.R</code></a>, <a href="https://github.com/nicholasdavies/elixir/blob/main/R/convenience.R" class="external-link"><code>R/convenience.R</code></a></small>
      <div class="d-none name"><code>expr_match.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Match and extract patterns in an <a href="elixir-expression.html">expression</a> or a list of expressions.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">expr_match</span><span class="op">(</span><span class="va">expr</span>, <span class="va">pattern</span>, n <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>    dotnames <span class="op">=</span> <span class="cn">FALSE</span>, env <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sys.parent.html" class="external-link">parent.frame</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">expr_count</span><span class="op">(</span><span class="va">expr</span>, <span class="va">pattern</span>, n <span class="op">=</span> <span class="cn">Inf</span>, env <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sys.parent.html" class="external-link">parent.frame</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">expr_detect</span><span class="op">(</span><span class="va">expr</span>, <span class="va">pattern</span>, n <span class="op">=</span> <span class="cn">Inf</span>, env <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sys.parent.html" class="external-link">parent.frame</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">expr_extract</span><span class="op">(</span><span class="va">expr</span>, <span class="va">pattern</span>, what <span class="op">=</span> <span class="st">"match"</span>, n <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>    dotnames <span class="op">=</span> <span class="cn">FALSE</span>, gather <span class="op">=</span> <span class="cn">FALSE</span>, env <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sys.parent.html" class="external-link">parent.frame</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">expr_locate</span><span class="op">(</span><span class="va">expr</span>, <span class="va">pattern</span>, n <span class="op">=</span> <span class="cn">Inf</span>, gather <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>    env <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sys.parent.html" class="external-link">parent.frame</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-expr">expr<a class="anchor" aria-label="anchor" href="#arg-expr"></a></dt>
<dd><p>Input. An <a href="elixir-expression.html">expression</a>, <a href="expr_list.html">expr_list</a>, or
<code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code> of expressions.</p></dd>


<dt id="arg-pattern">pattern<a class="anchor" aria-label="anchor" href="#arg-pattern"></a></dt>
<dd><p>Pattern to look for. An <a href="elixir-expression.html">expression</a>, a
length-one <a href="expr_list.html">expr_list</a>, or a length-one <a href="https://rdrr.io/r/base/list.html" class="external-link">list</a> of expressions. The
question mark syntax (see <a href="elixir-expression.html">expression</a>) can be used
to specify alternatives.</p></dd>


<dt id="arg-n">n<a class="anchor" aria-label="anchor" href="#arg-n"></a></dt>
<dd><p>Maximum number of matches to make in each expression; default is
<code>Inf</code>.</p></dd>


<dt id="arg-dotnames">dotnames<a class="anchor" aria-label="anchor" href="#arg-dotnames"></a></dt>
<dd><p>Normally, patterns like <code>.A</code>, <code>..B</code>, <code>...C</code>, etc, are named
just <code>A</code>, <code>B</code>, <code>C</code>, etc., in the returned matches, without the dot(s)
before each name. With <code>dotnames = TRUE</code>, the dots are kept.</p></dd>


<dt id="arg-env">env<a class="anchor" aria-label="anchor" href="#arg-env"></a></dt>
<dd><p>Environment for injections in <code>expr</code>, <code>pattern</code> (see
<a href="elixir-expression.html">expression</a>).</p></dd>


<dt id="arg-what">what<a class="anchor" aria-label="anchor" href="#arg-what"></a></dt>
<dd><p>(<code>expr_extract</code> only) Name of the pattern to extract (or
<code>"match"</code>, the default, to extract the entire match).</p></dd>


<dt id="arg-gather">gather<a class="anchor" aria-label="anchor" href="#arg-gather"></a></dt>
<dd><p>(<code>expr_extract</code> and <code>expr_locate</code> only) Whether to only return
the successful matches, in a single unnested list.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p><code>expr_match</code> returns, for each expression in <code>expr</code>, either <code>NULL</code>
if there is no match, or an object of class <code>expr_match</code> if there is a
match. If <code>expr</code> is a single expression, just a single <code>NULL</code> or
<code>expr_match</code> object will be returned, but if <code>expr</code> is a list of
expressions, then a list of all results will be returned.</p>
<p>An <code>expr_match</code> object is a list containing the elements <code>alt</code> (if the
pattern contains several alternatives), <code>match</code>, <code>loc</code>, and
further elements corresponding to the capture tokens in <code>pattern</code> (see
below).</p>
<p>For return values of <code>expr_count</code>, <code>expr_detect</code>, <code>expr_extract</code>, and
<code>expr_locate</code>, see below.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>All of these functions are used to check whether an
<a href="elixir-expression.html">expression</a> matches a specific pattern, and if it does,
retrieve the details of the match. These functions are inspired by similar
functions in the <code>stringr</code> package.</p>
    </div>
    <div class="section level2">
    <h2 id="details-for-expr-match">Details for expr_match<a class="anchor" aria-label="anchor" href="#details-for-expr-match"></a></h2>
    <p><code>expr_match</code> is the most general of the bunch. As an example, suppose you
had an expression containing the sum of two numbers (e.g.
<code>3.14159 + 2.71828</code>) and you wanted to extract the two numbers. You
could use the pattern <code>{ .A + .B }</code> to extract the match:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fl">3.14159</span> <span class="sc">+</span> <span class="fl">2.71828</span> }, { .A <span class="sc">+</span> .B })</span></code></pre><p></p></div>
<p>This gives you a list containing all the matches found. In this case,
there is one match, the details of which are contained in an object of
class <code>expr_match</code>. This object contains the following elements:</p><ul><li><p><code>match = quote(3.14159 + 2.71828)</code>, the entire match;</p></li>
<li><p><code>loc = NULL</code>, the location of the match within the expression;</p></li>
<li><p><code>A = 3.14159</code>, the part of the match corresponding to the <em>capture token</em>
<code>.A</code>;</p></li>
<li><p><code>B = 2.71828</code>, the part of the match corresponding to the <em>capture token</em>
<code>.B</code>.</p></li>
</ul><p>We can also use a list of expressions for <code>expr</code>, as in:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>ex <span class="ot">&lt;-</span> <span class="fu">expr_list</span>({ x <span class="sc">+</span> y }, { kappa <span class="sc">+</span> lambda }, { p <span class="sc">*</span> z })</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">expr_match</span>(ex, { .A <span class="sc">+</span> .B })</span></code></pre><p></p></div>
<p>This returns a list with one entry for each element of the list <code>ex</code>; for
the expressions that match (<code>ex[[1]]</code> and <code>ex[[2]]</code>) an <code>expr_match</code> object
is returned, while for the expression that does not match (<code>ex[[3]]</code>),
<code>NULL</code> is returned.</p>
    </div>
    <div class="section level2">
    <h2 id="pattern-syntax">Pattern syntax<a class="anchor" aria-label="anchor" href="#pattern-syntax"></a></h2>
    <p>The <code>pattern</code> expression (e.g. <code>{.A + .B}</code> in the above) follows a special
syntax.</p><div class="section">
<h3 id="capture-tokens">Capture tokens<a class="anchor" aria-label="anchor" href="#capture-tokens"></a></h3>


<p>First, these patterns can contain <em>capture tokens</em>, which are names starting
with one to three periods and match to the following:</p><ul><li><p><code>.A</code> matches any single token</p></li>
<li><p><code>..A</code> matches any sub-expression</p></li>
<li><p><code>...A</code> matches any number of function arguments</p></li>
</ul><p>Above, "A" can be any name consisting of an alphabetical character (<code>a-z</code>,
<code>A-Z</code>) followed by any number of alphanumeric characters (<code>a-z</code>, <code>A-Z</code>,
<code>0-9</code>), underscores (<code>_</code>), or dots (<code>.</code>). This is the name given to the
match in the returned list. Alternatively, it can be any name starting with
an underscore (e.g. so the entire token could be <code>._</code> or <code>..._1</code>), in which
case the match is made but the capture is discarded.</p>
<p>Additionally, the single-token pattern (e.g. <code>.A</code>) can be extended as
follows:</p><ul><li><p>Use <code>`.A:classname`</code> to require that the class of the object be
"classname" (or contain "classname" if the object has multiple classes); so
e.g. <code>`.A:name`</code> matches a single name (i.e. symbol).</p></li>
<li><p>Use <code>`.A/regexp`</code> to require a regular expression match <code>regexp</code>; so
e.g. <code>`.A:name/ee`</code> will match symbols with two consecutive lowercase
letter 'e's;</p></li>
<li><p>Use <code>`.A|test`</code> to require that the expression <code>test</code> evaluates to
<code>TRUE</code>, where <code>.</code> can be used as a stand-in for the matched token; so e.g.
<code>`.A:numeric|.&gt;5`</code> will match numbers greater than 5.</p></li>
</ul><p>The <code>regexp</code> and <code>test</code> specifiers cannot be used together, and have to come
after the <code>classname</code> specifier if one appears. These special syntaxes
require the whole symbol to be wrapped in backticks, as in the examples
above, so that they parse as symbols.</p>
</div>

<div class="section">
<h3 id="matching-function-arguments">Matching function arguments<a class="anchor" aria-label="anchor" href="#matching-function-arguments"></a></h3>


<p>If you wish to match a single, unnamed function argument, you can use a
capture token of the form <code>.A</code> (single-token argument) or <code>..B</code> (expression
argument). To match all arguments, including named ones, use a capture token
of the form <code>...C</code>. For example, these all match:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>() }, { <span class="fu">.F</span>() })</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="dv">1</span>) }, { <span class="fu">.F</span>(.X) })</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="dv">1</span>) }, { <span class="fu">myfunc</span>(..X) })</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="dv">1</span>, <span class="dv">2</span>) }, { <span class="fu">.F</span>(.X, .Y) })</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>() }, { <span class="fu">myfunc</span>(...A) })</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="dv">1</span>) }, { <span class="fu">.F</span>(...A) })</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="dv">2</span>, <span class="at">c =</span> <span class="dv">3</span>) }, { <span class="fu">myfunc</span>(...A) })</span></code></pre><p></p></div>
<p>but these do not:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>() }, { <span class="fu">.F</span>(.X) })</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>() }, { <span class="fu">.F</span>(..X) })</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="at">a =</span> <span class="dv">1</span>) }, { <span class="fu">.F</span>(.X) })</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="at">a =</span> <span class="dv">1</span> <span class="sc">+</span> <span class="dv">1</span>) }, { <span class="fu">.F</span>(..X) })</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="dv">1</span>,<span class="dv">2</span>) }, { <span class="fu">.F</span>(..X) })</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="fu">expr_match</span>({ <span class="fu">myfunc</span>(<span class="at">a =</span> <span class="dv">1</span>, <span class="at">b =</span> <span class="dv">2</span>) }, { <span class="fu">.F</span>(...X, ...Y) })</span></code></pre><p></p></div>
<p>There may be support for named arguments in patterns in the future, e.g. a
pattern such as <code>{ f(a = .X) }</code> that would match an expression like
<code>{ f(a = 1) }</code>, but that is currently not supported. So currently you can
only match named function arguments using the <code>...X</code> syntax.</p>
</div>

<div class="section">
<h3 id="anchoring-versus-recursing-into-expressions">Anchoring versus recursing into expressions<a class="anchor" aria-label="anchor" href="#anchoring-versus-recursing-into-expressions"></a></h3>


<p>If you want your anchor your pattern, i.e. ensure that the pattern will only
match at the "outer level" of your expression(s), without matching to any
sub-expressions within, use a tilde (<code>~</code>) outside the braces (see
<a href="elixir-expression.html">expression</a> for details). For example,
<code>expr_match({1 + 2 + 3 + 4}, ~{..A + .B})</code> only gives one match, to the
addition at the outermost level of <code>1 + 2 + 3</code> plus <code>4</code>, but
<code>expr_match({1 + 2 + 3 + 4}, {..A + .B})</code> also matches to the inner
additions of <code>1 + 2</code> plus <code>3</code> and <code>1</code> plus <code>2</code>.</p>
</div>

<div class="section">
<h3 id="alternatives">Alternatives<a class="anchor" aria-label="anchor" href="#alternatives"></a></h3>


<p>Finally, <code>pattern</code> can be a series of alternatives, using the operator <code>?</code>
for specifying alternatives (see <a href="elixir-expression.html">expression</a> for
details). Results from the first matching pattern among these alternatives
will be returned, and the returned <code>expr_match</code> object will include a
special element named "alt" giving the index of the matching alternative
(see examples).</p>
</div>

    </div>
    <div class="section level2">
    <h2 id="details-for-expr-count-expr-detect-expr-extract-and-expr-locate">Details for <code>expr_count</code>, <code>expr_detect</code>, <code>expr_extract</code>, and <code>expr_locate</code><a class="anchor" aria-label="anchor" href="#details-for-expr-count-expr-detect-expr-extract-and-expr-locate"></a></h2>
    <p>These shortcut functions return only some of the information given by
<code>expr_match</code>, but often in a more convenient format.</p>
<p><code>expr_count</code> returns an integer vector with one element for every expression
in <code>expr</code>, each element giving the number of matches of <code>pattern</code> found.</p>
<p><code>expr_detect</code> returns a logical vector with one element for every expression
in <code>expr</code>, each element giving whether at least one match of <code>pattern</code> was
found.</p>
<p><code>expr_extract</code> returns, for each expression in <code>expr</code>, a list of all the
complete matches. Or, by specifing a capture token name in the argument
<code>which</code>, those can be extracted instead. For example:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">expr_extract</span>(<span class="fu">expr_list</span>({(a<span class="sc">+</span>b)<span class="sc">+</span>(x<span class="sc">+</span>y)},</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>    {<span class="st">"H"</span><span class="sc">*</span><span class="st">"I"</span>}, {<span class="dv">3</span><span class="sc">+</span><span class="dv">4</span>}), {.A <span class="sc">+</span> .B}, <span class="st">"A"</span>)</span></code></pre><p></p></div>
<p>gives <code>list(list(quote(a), quote(x)), NULL, list(3))</code>.</p>
<p>Using <code>gather = TRUE</code> with <code>expr_extract</code> returns only the succesful matches
in a single, unnested list; so the above call to <code>expr_extract</code> with
<code>gather = TRUE</code> would give <code>list(quote(a), quote(x), 3)</code>.</p>
<p>Finally, <code>expr_locate</code> is similar to <code>expr_extract</code> but it returns the
location within <code>expr</code> of each successful match.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="expr_replace.html">expr_replace()</a></code> to replace patterns in expressions.</p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu">expr_match</span><span class="op">(</span><span class="op">{</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">2</span> <span class="op">}</span>, <span class="op">{</span> <span class="va">.A</span> <span class="op">+</span> <span class="va">.B</span> <span class="op">}</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr_match: list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   list(match = quote(1 + 2), loc = NULL, A = 1, B = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># match to one of several alternatives</span></span></span>
<span class="r-in"><span><span class="fu">expr_match</span><span class="op">(</span><span class="op">{</span> <span class="fl">5</span> <span class="op">-</span> <span class="fl">1</span> <span class="op">}</span>, <span class="op">{</span> <span class="va">.A</span> <span class="op">+</span> <span class="va">.B</span> <span class="op">}</span> <span class="op">?</span> <span class="op">{</span> <span class="va">.A</span> <span class="op">-</span> <span class="va">.B</span> <span class="op">}</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr_match: list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   list(alt = 2L, match = quote(5 - 1), loc = NULL, A = 5, B = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Nicholas Davies.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

