TODO

Converting elixir to work with formulae.

> expr_apply(
>   x,
>   f,
>   depth = Inf,
>   into = FALSE,
>   order = c("pre", "post"),
>   how = c("replace", "unlist", "unique"),
>   env = parent.frame()
> )

First arg is the R object; can be an expression, or a list of
arbitrary nestedness potentially containing expressions.
This could be expanded to include formulae. !!CHANGE
[x] edit
[x] test
[x] docs

> expr_match(expr, pattern, n = Inf,
>     dotnames = FALSE, env = parent.frame())
> expr_count(expr, pattern, n = Inf, env = parent.frame())
> expr_detect(expr, pattern, n = Inf, env = parent.frame())
> expr_extract(expr, pattern, what = "match", n = Inf,
>     dotnames = FALSE, gather = FALSE, env = parent.frame())
> expr_locate(expr, pattern, n = Inf, gather = FALSE,
>     env = parent.frame())
Yes, expr can be a formula or expression !! CHANGE
pattern: could only be an expression.
[x] edit
[x] test
[x] docs

> expr_replace(expr, ..., patterns, replacements,
>     n = Inf, env = parent.frame())
Yes, expr could be a formula !! CHANGE
[x] edit
[x] test
[x] docs


> expr_list(..., env = parent.frame())
I think leave it.

> expr_sub(expr, idx, env = parent.frame())
> expr_sub(expr, idx, env = parent.frame()) <- value

Yes !! CHANGE
[x] edit
[x] test
[x] docs

> lang2str(x)
Yes !! CHANGE
[x] edit
[x] test
[x] docs


[x] Change docs for 'expression' as well
Check all docs

X   Make sure NA into doesn't conflict with other into = NA stuff
-   Rename expr_translate to something else?
-   The only use case for expr_list, really, is within patterns / replacements
    of expr_replace. Reflect this in docs.
X   I think the tilde is nicer as an anchor than as an into. DONE

-   I think would be good to do a bit of a refactor.
-   Attributes can be attached to calls but not to names. Solution could be to
    store either just names, or all expressions, as expression(x), attaching
    attributes to that. This would allow e = expr_list(...) then e[[1]].

-   functions from stringr to emulate:
        str_detect
        str_match -- good
        str_extract -- would be like expr_match's full match, no group matches.
        str_replace -- good
        str_locate -- location of matches; this would need some extra function
            like expr_sub() and expr_sub()<- so that locations like c(1L, 2L, 3L)
            can be used e.g. expr_sub(expr, c(1,2,3)) === expr[[1]][[2]][[3]].
-    functionality to add: ._, .._, ..._ would be unnamed groups.
-    add tests to .., like how . has .A:name, etc. Maybe ..A{1}?{2}

-   make use of "rules" strings consistent across functions and ideally using
    the same ruleset


I think it might be a good idea to restrict the function of this package
to something much more circumscribed, just translating R "expressions" into
C++ or Lua, rather than translating "statements" or functions all at a time.

For translating functions, I am leaning more towards the Lua route in the long
term.

This might mean getting rid of translation of assignment operators completely
and of braces.

Or, have separate functions for translating expressions and for translating
functions. And have a special restricted subset of R that runs and produces
valid R code, but can also be translated into C++ or Lua code that does the
same thing.



# use cases for language tools in miasma0

## mangle: used a ton

## expr_add, expr_subtract: used in many places

## is_identifier: used about 10x in parser.R

## spec_as_list: used in parser.R and also within language_tools.R, where I'm not sure it's needed

## match_params: couple of times
args = match_params(prototype$arglist, args, func_name);
# Also have this note in macro_Rt.R, but no actual use of match_params
cpp = function(model, IR, name, ..., tolerance) {
    # TODO Note to readers of the code -- miasma passes ellipsis arguments through to macros as an actual list
    # containing all additional parameters not otherwise captured. That's why there is no list() around the ...
    # in the line below -- we would ordinarily need something like as.character(substitute(list(...))[-1L]).
    # Perhaps clarify this by renaming the parameters "states..." or "inf_states..." and changing match_params
    # to accept one argument whose name ends in "..." but is not "...", giving params to that arg.
    inf_states = as.character(as.list(substitute(...)[-1])[[1]]);
    ## . . .
}

## func_str: couple of times just within language_tools.R
stop(..., "  Function signature is ", func_str(func_name, func_def), ".")
