% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/basic.R
\name{expr_list}
\alias{expr_list}
\alias{[.expr_list}
\alias{[<-.expr_list}
\title{Make a list of expressions}
\usage{
expr_list(..., env = parent.frame())

\method{[}{expr_list}(xl, i)

\method{[}{expr_list}(xl, i) <- value
}
\arguments{
\item{...}{Expressions to include in the list. If the arguments are named,
these will be passed on to the returned list.}

\item{env}{Environment for injections in \code{...} (see \link{expression}).}

\item{xl}{An \code{expr_list}.}

\item{i}{Index for subsetting the \code{expr_list}; an integer, numeric, logical,
or character vector (for named \code{expr_list}s) interpreted in the usual R way.}

\item{value}{Replacement; an \code{expr_list}, an expression, or a list of
expressions.}
}
\value{
A list of expressions, of class \code{expr_list}.
}
\description{
Constructs a list of expressions, with support for Elixir's special
\link{expression} syntax (expression literals with \code{{}}, alternatives with \verb{?},
and recursion with \code{~}).
}
\details{
Be aware that using the \code{[[} indexing operator on an object of class
\code{expr_list} discards information about whether that element of the list is
marked for recursion. In other words, if \code{xl <- expr_list({.A}, ~{.A})},
then \code{xl[[1]]} and \code{xl[[2]]} are both equal to the "bare" symbol \code{.A}, so
the information that the second element of the list should recurse has been
lost. Consequently, in e.g. \code{expr_match(expr, xl[[2]])}, it will be as
though the tilde isn't there, and no recursion into \code{expr} will be done. Use
the \code{[} operator instead, which retains recursion information;
\code{expr_match(expr, xl[2])} will work as expected.

Note that when you replace part of an \code{expr_list} with another \code{expr_list},
the recursion information from the "replacement" \code{expr_list} is copied over,
while replacing part of an \code{expr_list} with an expression or a "plain" list
of expressions retains the existing recursion information.
}
\examples{
expr_list(
   { 1 + 1 = 2 } ? { 2 + 2 = 4 },
   { y = a * x + b },
   ~{ .A }
)

# There is support for rlang's injection operators.
var = as.name("myvar")
expr_list({ 1 }, { !!var }, { (!!var)^2 })
}
