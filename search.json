[{"path":"https://nicholasdavies.github.io/elixir/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Nicholas G. Davies Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://nicholasdavies.github.io/elixir/articles/elixir.html","id":"find-and-replace-for-language-objects","dir":"Articles","previous_headings":"","what":"Find and replace for language objects","title":"Introduction to elixir","text":"Sometimes want detect certain patterns within expression list expressions, easily replace certain pattern another. working strings, regular expressions handy way accomplishing tasks. elixir provides sort “regular expressions R expressions” functionality functions expr_match(), expr_replace(), “shortcut” functions expr_count(), expr_detect(), expr_extract(), expr_locate(). Frequent users stringr package recognize intentional similarity functions str_match(), str_replace(), str_count(), str_detect(), str_extract(), str_locate() stringr. easiest way demonstrate example.","code":""},{"path":"https://nicholasdavies.github.io/elixir/articles/elixir.html","id":"example-a-domain-specific-language-for-ordinary-differential-equations","dir":"Articles","previous_headings":"Find and replace for language objects","what":"Example: a domain-specific language for ordinary differential equations","title":"Introduction to elixir","text":"Lotka-Volterra equations can used model predator-prey interaction system ordinary differential equations: dx/dt = \\alpha x - \\beta x y \\\\ dy/dt = -\\gamma y + \\delta x y , x predator density, y prey density, \\alpha prey birth rate, \\beta rate prey killed predator, \\gamma predator net death rate absence prey eat, \\delta effect eating prey predator birth rate. One implement R using package deSolve:  run last two lines commented , see solution plotted . (lines commented deSolve isn’t required build vignette.) Let’s suppose instead want start set quoted statements like : turn components . one approach elixir. aim isn’t make something totally robust, just get something running, demonstrate use package. First, want set variable times set integers running 0 specified t_end within system. can look statement form t_end = .X like : elixir allows quote expressions inline using { curly braces } . ’s sort equivalent \"quotation marks\" string. handy avoid equals sign = interpreted naming parameter quote rlang::expr: can extract number 100 list returned expr_match, instead use shortcut, expr_extract: always returns list many entries matches, two statements form t_end = .X two-element list. can tell elixir stop first match: use expr_count make sure exactly one t_end = .X statement: set times like : OK, ’s done. Now let’s extract initial state vector. want look patterns form .X(0) = .V: , ’ll use expr_extract pull two needed components, names states (“x” “y”) initial values (1). Now parameters, might initially think use: picks t_end misses alpha beta. reason latter two components missed .P = .X, .X matches single token, 1/6 expression three tokens, /, 1, 6. ’ll use ..X instead .X can match subexpression: can also filter t_end adding “test” capture token .P like : Anything | interpreted condition evaluate, match succeeds condition evaluates TRUE. Within condition, . placeholder matched token, can also use name token , .e. P. Note wrap whole capture token backticks gets read single symbol. together, can get parameters like : need use eval captured ..X order evaluate quoted expressions. Capturing ordinary differential equations , inserting function deSolve can use, requires us look patterns dX/dt = ...; since “dX” one symbol, check make sure symbol starts lowercase d: , :name checks captured element .class name. Let’s extract statements: can now use expr_replace change e.g. dX/dt = ... dX <- ... valid R assignment statement: Let’s also extract names derivatives , .e. dx dy: Finally put function using rlang injection operators: Putting together wrapper function, get something like :","code":"y <- c(x = 1, y = 1) times <- 0:100 parms <- c(alpha = 1/6, beta = 1/3, gamma = 0.25, delta = 0.25)   func <- function(t, y, parms) {     with(as.list(c(y, parms)), {          dx <- alpha * x - beta * x * y          dy <- -gamma * y + delta * x * y          return (list(c(dx, dy)))     }) }  # Run this with: # sol <- deSolve::ode(y, times, func, parms)  # matplot(sol[, 1], sol[, -1], type = \"l\") system <- quote({     t_end = 100      x(0) = 1     y(0) = 1      dx/dt = alpha * x - beta * x * y     dy/dt = -gamma * y + delta * x * y      alpha = 1/6     beta = 1/3     gamma = 0.25     delta = 0.25 }) expr_match(system, { t_end = .X }) #> expr_match: list( #>   list(match = quote(t_end = 100), loc = 2L, X = 100) #> ) # neither of these will work expr_match(system, quote(t_end = .X)) expr_match(system, rlang::expr(t_end = .X))  # instead you would have to do something like this: expr_match(system, quote((t_end = .X))[[2]]) expr_match(system, rlang::expr((t_end = .X))[[2]])  # This works because the expression (t_end = .X) is a call, which is list-like # with two elements:  # [[1]] is the symbol `(`, and [[2]] is the call t_end = .X. expr_extract(system, { t_end = .X }, \"X\") #> [[1]] #> [1] 100 expr_extract(system, { t_end = .X }, \"X\", n = 1) #> [[1]] #> [1] 100 if (expr_count(system, { t_end = .X }) != 1) {     stop(\"Need exactly one specification of end time.\") } times <- 0:expr_extract(system, { t_end = .X }, \"X\")[[1]] times #>   [1]   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17 #>  [19]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 #>  [37]  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53 #>  [55]  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71 #>  [73]  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89 #>  [91]  90  91  92  93  94  95  96  97  98  99 100 expr_match(system, { .X(0) = .V }) #> expr_match: list( #>   list(match = quote(x(0) = 1), loc = 3L, X = quote(x), V = 1), #>   list(match = quote(y(0) = 1), loc = 4L, X = quote(y), V = 1) #> ) expr_extract(system, { .X(0) = .V }, \"X\") #> [[1]] #> x #>  #> [[2]] #> y expr_extract(system, { .X(0) = .V }, \"V\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1  y <- as.numeric(expr_extract(system, { .X(0) = .V }, \"V\")) names(y) <- as.character(expr_extract(system, { .X(0) = .V }, \"X\")) y #> x y  #> 1 1 expr_match(system, { .P = .X }) #> expr_match: list( #>   list(match = quote(t_end = 100), loc = 2L, P = quote(t_end), X = 100), #>   list(match = quote(gamma = 0.25), loc = 9L, P = quote(gamma), X = 0.25), #>   list(match = quote(delta = 0.25), loc = 10L, P = quote(delta), X = 0.25) #> ) expr_match(system, { .P = ..X }) #> expr_match: list( #>   list(match = quote(t_end = 100), loc = 2L, P = quote(t_end), X = 100), #>   list(match = quote(alpha = 1/6), loc = 7L, P = quote(alpha), X = quote(1/6)), #>   list(match = quote(beta = 1/3), loc = 8L, P = quote(beta), X = quote(1/3)), #>   list(match = quote(gamma = 0.25), loc = 9L, P = quote(gamma), X = 0.25), #>   list(match = quote(delta = 0.25), loc = 10L, P = quote(delta), X = 0.25) #> ) expr_match(system, { `.P|P != \"t_end\"` = ..X }) #> expr_match: list( #>   list(match = quote(alpha = 1/6), loc = 7L, P = quote(alpha), X = quote(1/6)), #>   list(match = quote(beta = 1/3), loc = 8L, P = quote(beta), X = quote(1/3)), #>   list(match = quote(gamma = 0.25), loc = 9L, P = quote(gamma), X = 0.25), #>   list(match = quote(delta = 0.25), loc = 10L, P = quote(delta), X = 0.25) #> ) parms <- expr_extract(system, { `.P|P != \"t_end\"` = ..X }, \"X\") parms <- sapply(parms, eval) names(parms) <- as.character(expr_extract(system, { `.P|P != \"t_end\"` = ..X }, \"P\")) expr_match(system, { `.A:name|substr(A, 1, 1) == \"d\"`/dt = ..X }) #> expr_match: list( #>   list(match = quote(dx/dt = alpha * x - beta * x * y), loc = 5L, A = quote(dx), X = quote(alpha * x - beta * x * y)), #>   list(match = quote(dy/dt = -gamma * y + delta * x * y), loc = 6L, A = quote(dy), X = quote(-gamma * y + delta * x * y)) #> ) statements <- expr_extract(system, { `.A:name|substr(A, 1, 1) == \"d\"`/dt = ..X }) statements #> [[1]] #> dx/dt = alpha * x - beta * x * y #>  #> [[2]] #> dy/dt = -gamma * y + delta * x * y R_statements <- expr_replace(statements,     { `.A:name|substr(A, 1, 1) == \"d\"`/dt = ..X },     { .A <- ..X }) R_statements #> [[1]] #> dx <- alpha * x - beta * x * y #>  #> [[2]] #> dy <- -gamma * y + delta * x * y derivatives <- expr_replace(R_statements, { .D <- ..X }, { .D }) derivatives #> [[1]] #> dx #>  #> [[2]] #> dy func <- eval(rlang::expr(     function(t, y, parms)     {         with(as.list(c(y, parms)), {             !!!R_statements             return (list(c(!!!derivatives)))         })     } )) run_ode <- function(system) {     # Get times     if (expr_count(system, { t_end = .X }) != 1) {         stop(\"Need exactly one specification of end time.\")     }     times <- 0:expr_extract(system, { t_end = .X }, \"X\")[[1]]          # Get initial state     y <- as.numeric(expr_extract(system, { .X(0) = .V }, \"V\"))     names(y) <- as.character(expr_extract(system, { .X(0) = .V }, \"X\"))          # Get parameters     parms <- expr_extract(system, { `.P|P != \"t_end\"` = ..X }, \"X\")     parms <- sapply(parms, eval)     names(parms) <- as.character(expr_extract(system, { `.P|P != \"t_end\"` = ..X }, \"P\"))          # Get statements     statements <- expr_extract(system, { `.A:name|substr(A, 1, 1) == \"d\"`/dt = ..X })     R_statements <- expr_replace(statements,         { `.A:name|substr(A, 1, 1) == \"d\"`/dt = ..X },         { .A <- ..X })     derivatives <- expr_replace(R_statements, { .D <- ..X }, { .D })          func <- eval(rlang::expr(         function(t, y, parms)         {             with(as.list(c(y, parms)), {                 !!!R_statements                 return (list(c(!!!derivatives)))             })         }     ))          # uncomment if deSolve is available:     # sol <- deSolve::ode(y, times, func, parms)      # matplot(sol[, 1], sol[, -1], type = \"l\") }  system <- quote({     t_end = 100      x(0) = 1     y(0) = 1      dx/dt = alpha * x - beta * x * y     dy/dt = -gamma * y + delta * x * y      alpha = 1/6     beta = 1/3     gamma = 0.25     delta = 0.25 })  run_ode(system)"},{"path":"https://nicholasdavies.github.io/elixir/articles/elixir.html","id":"other-elixir-features","dir":"Articles","previous_headings":"","what":"Other elixir features","title":"Introduction to elixir","text":"function expr_apply() allows transform extract information nested list structures contain expressions, big structure want check variable names make certain replacements, may useful. expr_sub() offers interface extracting replacing part expression; one advantage [[ allows use NULL index, gives back whole expression. lang2str() opposite str2lang(); like deparse1() new since R 4.0.0, collapse = \"\" instead collapse = \" \". Finally, meld(), translate(), reindent() various experimental functions constructing code using R.","code":""},{"path":"https://nicholasdavies.github.io/elixir/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nicholas Davies. Maintainer, author, copyright holder.","code":""},{"path":"https://nicholasdavies.github.io/elixir/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Davies N (2025). elixir: Transmutation Languages. R package version 0.1.1, https://github.com/nicholasdavies/elixir.","code":"@Manual{,   title = {elixir: Transmutation of Languages},   author = {Nicholas Davies},   year = {2025},   note = {R package version 0.1.1},   url = {https://github.com/nicholasdavies/elixir}, }"},{"path":"https://nicholasdavies.github.io/elixir/index.html","id":"elixir-transmutation-of-languages","dir":"","previous_headings":"","what":"Transmutation of Languages","title":"Transmutation of Languages","text":"Tools transforming R expressions, including programming languages.","code":""},{"path":"https://nicholasdavies.github.io/elixir/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Transmutation of Languages","text":"can install development version elixir GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"nicholasdavies/elixir\")"},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir-expression.html","id":null,"dir":"Reference","previous_headings":"","what":"Expressions in elixir — elixir-expression","title":"Expressions in elixir — elixir-expression","text":"elixir primarily package working calls \"expressions\", sense R object rlang::is_expression() returns TRUE. includes calls, like results evaluating quote(f(x)) quote(:b), symbols like quote(z), syntactic literals like 2.5, \"hello\", NULL, FALSE, . many cases, can also use elixir work formulas, even though rlang::is_expression() returns FALSE formulas. confused built-type base::expression, essentially special way storing vector multiple \"expressions\". elixir use type; see expr_list() instead.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir-expression.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expressions in elixir — elixir-expression","text":"","code":"expr_list(number = { `.A:numeric` } ? { `.A:integer` },     string = { `.A:character` }, symbol = { `.A:name` }) expr_match({ 1 * 2 }, ~{ .A * .B }) expr_match({ 1 * 2 }, { `.A:numeric` }) expr_replace({ y = a*x^3 + b*x^2 + c*x^1 + d*x^0 },     { ..X ^ ..N }, { pow(..X, ..N) })"},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir-expression.html","id":"specifying-expressions-in-elixir","dir":"Reference","previous_headings":"","what":"Specifying expressions in elixir","title":"Expressions in elixir — elixir-expression","text":"elixir package functions starting expr_ work expressions. functions accept special (optional) syntax specifying expressions involves symbols {}, ?, ~, well rlang injection operator, !! splice operator, !!!). base R, want store expression x + y variable pass function, need use base::quote() rlang::expr(), Elixir expr_ function also accept \"expression literal\" wrapped braces, {}. , example, rather translate(quote(x ^ y), \"C++\") can write translate({ x ^ y }, \"C++\"). works braces provided \"directly\"; , expr <- quote({ x ^ y }); translate(expr, \"C++\"), braces interpreted special way. Anything braces essentially gets put rlang::expr(), can use !! (.e. rlang::injection-operator) !!! (.e. rlang::splice-operator). env parameter relevant elixir functions, defaulting parent.frame(), injection operations evaluated.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir-expression.html","id":"special-syntax-for-patterns-and-replacements","dir":"Reference","previous_headings":"","what":"Special syntax for patterns and replacements","title":"Expressions in elixir — elixir-expression","text":"Additionally, functions (expr_match(), expr_count(), expr_detect(), expr_extract(), expr_locate(), expr_replace()) take pattern /replacement arguments specify patterns match expression /replacement expressions replace matches . pattern replacement arguments, can use question mark operator ? specify alternatives. example, match either token cat dog, can use expr_match(expr, { cat } ? { dog }). can chain together many alternatives needed. Alternatively, list expressions z, can use single question mark name list, like : expr_match(expr, ?z) elixir treat list set alternatives. using expr_replace() set alternatives pattern, replacement needs either single expression, set alternative expressions number alternatives pattern. can also use tilde operator ~ specify given pattern \"anchored\" top level expression, \"recurse \" expression. example,   numbers 2 5 match. However,   numbers 2, 5, 1 4 match, pattern can recurse third expression 1 + 4.","code":"exprs = expr_list(2, 5, {1 + 4}) expr_match(exprs, ~{ `.A:numeric` }) exprs = expr_list(2, 5, {1 + 4}) expr_match(exprs, { `.A:numeric` })"},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir-rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Rules for understanding languages — elixir-rules","title":"Rules for understanding languages — elixir-rules","text":"Several elixir functions – namely meld(), reindent(), translate() – take argument rules assists functions interpreting arguments.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir-rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rules for understanding languages — elixir-rules","text":"cases, rules can either character string identifying set built-rules specific language purpose – currently, elixir accepts \"C\", \"C++\", \"Lua\", \"R\" – list elements required interpretation. elixir:::ruleset contains built-rules. Passing empty list() rules argument elixir function cause complain missing components, one way discerning needed given function, usually error messages quite cover details needed.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir.html","id":null,"dir":"Reference","previous_headings":"","what":"elixir: Transmutation of languages — elixir","title":"elixir: Transmutation of languages — elixir","text":"elixir set tools transforming R expressions, including programming languages.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"elixir: Transmutation of languages — elixir","text":"One neat features R can use language inspect . Expressions, functions, indeed entire R scripts can examined manipulated just like list, data.frame, R object. However, syntax manipulating R language objects little tricky. Packages rlang help make task easier. elixir makes extra shortcuts available, geared advanced R users. elixir provides functions finding, extracting, replacing patterns 'R' language objects, similarly regular expressions can used find, extract, replace patterns text. also provides functions generating code using specially-formatted template files translating 'R' expressions similar expressions programming languages. package may helpful advanced uses 'R' expressions, developing domain-specific languages.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir.html","id":"find-and-replace-for-language-objects","dir":"Reference","previous_headings":"","what":"Find and replace for language objects","title":"elixir: Transmutation of languages — elixir","text":"Sometimes want detect certain patterns within expression list expressions, easily replace certain pattern another. working strings, regular expressions handy way accomplishing tasks. elixir provides sort \"regular expressions R expressions\" functionality functions expr_match(), expr_replace(), \"shortcut\" functions expr_count(), expr_detect(), expr_extract(), expr_locate().","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/elixir.html","id":"other-elixir-features","dir":"Reference","previous_headings":"","what":"Other elixir features","title":"elixir: Transmutation of languages — elixir","text":"function expr_apply() allows transform extract information nested list structures contain expressions, big structure want check variable names make certain replacements, may useful. expr_sub() offers interface extracting replacing part expression; one advantage [[ allows use NULL index, gives back whole expression. lang2str() opposite base::str2lang(); like deparse1() new since R 4.0.0, collapse = \"\" instead collapse = \" \". Finally, meld(), translate(), reindent() various experimental functions constructing code using R.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function over expressions — expr_apply","title":"Apply a function over expressions — expr_apply","text":"Recursively apply function expression, expression elements list, optionally subexpressions within expressions.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function over expressions — expr_apply","text":"","code":"expr_apply(   x,   f,   depth = Inf,   into = FALSE,   order = c(\"pre\", \"post\"),   how = c(\"replace\", \"unlist\", \"unique\"),   env = parent.frame() )"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function over expressions — expr_apply","text":"x R object; can expression, formula, list arbitrary nestedness potentially containing multiple expressions formulas. f Function apply expressions within x; takes 1 3 arguments. depth many levels recurse lists; default Inf. Whether recurse expressions. Can TRUE visit subexpressions, FALSE recurse, \"leaves\" recurse apply f terminal nodes expressions (.e. symbols syntactic literals comprising expressions). order Whether parent node visited (\"pre\") (\"post\") children (terminology comes pre-order post-order depth-first search). effect == TRUE. structure result. env Environment injections x (see expression).","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function over expressions — expr_apply","text":"= \"replace\" (default), original object x f applied expressions within . = \"unlist\", unlist() applied . = \"unique\", first unlist() unique() applied.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_apply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function over expressions — expr_apply","text":"function f can take one three arguments. first argument expression f apply , f return kind replacement , modified version , argument. second argument list information name expression list x parents. Specifically, first element list name expression, second element list name \"parent\" expression, . elements chain unnamed, integer provided name. expression within another expression (happens = TRUE), signalled NULL top list, one level recursion expression. third argument integer vector, index x f currently operating. suitable use expr_sub().","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_apply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function over expressions — expr_apply","text":"","code":"expr_apply(list(quote(a + b), quote(c)), function(x) all.vars(x), how = \"unlist\") #> [1] \"a\" \"b\" \"c\""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a list of expressions — expr_list","title":"Make a list of expressions — expr_list","text":"Constructs list expressions, support elixir's special expression syntax (expression literals {} ~{}, alternatives ?).","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a list of expressions — expr_list","text":"","code":"expr_list(..., env = parent.frame())  # S3 method for class 'expr_list' xl[i]  # S3 method for class 'expr_list' xl[i] <- value"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a list of expressions — expr_list","text":"... Expressions include list. arguments named, passed returned list. env Environment injections ... (see expression). xl expr_list. Index subsetting expr_list; integer, numeric, logical, character vector (named expr_lists) interpreted usual R way. value Replacement; expr_list, expression, list expressions.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a list of expressions — expr_list","text":"list expressions, class expr_list.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a list of expressions — expr_list","text":"aware using [[ indexing operator object class expr_list discards information whether element list marked anchored. words, xl <- expr_list({.}, ~{.}), xl[[1]] xl[[2]] equal \"bare\" symbol ., information second element list anchored lost. Consequently, e.g. expr_match(expr, xl[[2]]), though tilde , xl[[2]] just match top level expr probably intended. Use [ operator instead, retains anchoring information; expr_match(expr, xl[2]) work expected. Note replace part expr_list another expr_list, anchoring information \"replacement\" expr_list copied , replacing part expr_list expression \"plain\" list expressions retains existing anchoring information.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a list of expressions — expr_list","text":"","code":"expr_list(    ~{ 1 + 1 = 2 } ? ~{ 2 + 2 = 4 },    ~{ y = a * x + b },    { .A } ) #> expr_list of length 3: ~{ 1 + 1 = 2 } ? ~{ 2 + 2 = 4 }, ~{ y = a * x + b }, { .A }  # There is support for rlang's injection operators. var = as.name(\"myvar\") expr_list({ 1 }, { !!var }, { (!!var)^2 }) #> expr_list of length 3: { 1 }, { myvar }, { myvar^2 }"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Find patterns in expressions — expr_match","title":"Find patterns in expressions — expr_match","text":"Match extract patterns expression list expressions.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find patterns in expressions — expr_match","text":"","code":"expr_match(expr, pattern, n = Inf,     dotnames = FALSE, env = parent.frame())  expr_count(expr, pattern, n = Inf, env = parent.frame()) expr_detect(expr, pattern, n = Inf, env = parent.frame()) expr_extract(expr, pattern, what = \"match\", n = Inf,     dotnames = FALSE, gather = FALSE, env = parent.frame()) expr_locate(expr, pattern, n = Inf, gather = FALSE,     env = parent.frame())"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find patterns in expressions — expr_match","text":"expr Input. expression, expr_list, list() expressions. Also works formulas lists formulas. pattern Pattern look . expression, length-one expr_list, length-one list expressions. question mark syntax (see expression) can used specify alternatives. n Maximum number matches make expression; default Inf. dotnames Normally, patterns like ., ..B, ...C, etc, named just , B, C, etc., returned matches, without dot(s) name. dotnames = TRUE, dots kept. env Environment injections expr, pattern (see expression). (expr_extract ) Name pattern extract (\"match\", default, extract entire match). gather (expr_extract expr_locate ) Whether return successful matches, single unnested list.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find patterns in expressions — expr_match","text":"expr_match returns, expression expr, either NULL match, object class expr_match match. expr single expression, just single NULL expr_match object returned, expr list expressions, list results returned. expr_match object list containing elements alt (pattern contains several alternatives), match, loc, elements corresponding capture tokens pattern (see ). return values expr_count, expr_detect, expr_extract, expr_locate, see .","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find patterns in expressions — expr_match","text":"functions used check whether expression matches specific pattern, , retrieve details match. functions inspired similar functions stringr package.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"details-for-expr-match","dir":"Reference","previous_headings":"","what":"Details for expr_match","title":"Find patterns in expressions — expr_match","text":"expr_match general bunch. example, suppose expression containing sum two numbers (e.g. 3.14159 + 2.71828) wanted extract two numbers. use pattern { .+ .B } extract match:   gives list containing matches found. case, one match, details contained object class expr_match. object contains following elements: match = quote(3.14159 + 2.71828), entire match; loc = NULL, location match within expression; = 3.14159, part match corresponding capture token .; B = 2.71828, part match corresponding capture token .B. can also use list expressions expr, :   returns list one entry element list ex; expressions match (ex[[1]] ex[[2]]) expr_match object returned, expression match (ex[[3]]), NULL returned.","code":"expr_match({ 3.14159 + 2.71828 }, { .A + .B }) ex <- expr_list({ x + y }, { kappa + lambda }, { p * z }) expr_match(ex, { .A + .B })"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"pattern-syntax","dir":"Reference","previous_headings":"","what":"Pattern syntax","title":"Find patterns in expressions — expr_match","text":"pattern expression (e.g. {.+ .B} ) follows special syntax.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"capture-tokens","dir":"Reference","previous_headings":"","what":"Capture tokens","title":"Find patterns in expressions — expr_match","text":"First, patterns can contain capture tokens, names starting one three periods match following: .matches single token ..matches sub-expression ...matches number function arguments , \"\" can name consisting alphabetical character (-z, -Z) followed number alphanumeric characters (-z, -Z, 0-9), underscores (_), dots (.). name given match returned list. Alternatively, can name starting underscore (e.g. entire token ._ ..._1), case match made capture discarded. Additionally, single-token pattern (e.g. .) can extended follows: Use `.:classname` require class object \"classname\" (contain \"classname\" object multiple classes); e.g. `.:name` matches single name (.e. symbol). Use `./regexp` require regular expression match regexp; e.g. `.:name/ee` match symbols two consecutive lowercase letter 'e's; Use `.|test` require expression test evaluates TRUE, . can used stand-matched token; e.g. `.:numeric|.>5` match numbers greater 5. regexp test specifiers used together, come classname specifier one appears. special syntaxes require whole symbol wrapped backticks, examples , parse symbols.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"matching-function-arguments","dir":"Reference","previous_headings":"","what":"Matching function arguments","title":"Find patterns in expressions — expr_match","text":"wish match single, unnamed function argument, can use capture token form .(single-token argument) ..B (expression argument). match arguments, including named ones, use capture token form ...C. example, match:   :   may support named arguments patterns future, e.g. pattern { f(= .X) } match expression like { f(= 1) }, currently supported. currently can match named function arguments using ...X syntax.","code":"expr_match({ myfunc() }, { .F() }) expr_match({ myfunc(1) }, { .F(.X) }) expr_match({ myfunc(1 + 1) }, { myfunc(..X) }) expr_match({ myfunc(1, 2) }, { .F(.X, .Y) }) expr_match({ myfunc() }, { myfunc(...A) }) expr_match({ myfunc(1) }, { .F(...A) }) expr_match({ myfunc(2, c = 3) }, { myfunc(...A) }) expr_match({ myfunc() }, { .F(.X) }) expr_match({ myfunc() }, { .F(..X) }) expr_match({ myfunc(a = 1) }, { .F(.X) }) expr_match({ myfunc(a = 1 + 1) }, { .F(..X) }) expr_match({ myfunc(1,2) }, { .F(..X) }) expr_match({ myfunc(a = 1, b = 2) }, { .F(...X, ...Y) })"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"anchoring-versus-recursing-into-expressions","dir":"Reference","previous_headings":"","what":"Anchoring versus recursing into expressions","title":"Find patterns in expressions — expr_match","text":"want anchor pattern, .e. ensure pattern match \"outer level\" expression(s), without matching sub-expressions within, use tilde (~) outside braces (see expression details). example, expr_match({1 + 2 + 3 + 4}, ~{..+ .B}) gives one match, addition outermost level 1 + 2 + 3 plus 4, expr_match({1 + 2 + 3 + 4}, {..+ .B}) also matches inner additions 1 + 2 plus 3 1 plus 2.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"alternatives","dir":"Reference","previous_headings":"","what":"Alternatives","title":"Find patterns in expressions — expr_match","text":"Finally, pattern can series alternatives, using operator ? specifying alternatives (see expression details). Results first matching pattern among alternatives returned, returned expr_match object include special element named \"alt\" giving index matching alternative (see examples).","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"details-for-expr-count-expr-detect-expr-extract-and-expr-locate","dir":"Reference","previous_headings":"","what":"Details for expr_count, expr_detect, expr_extract, and expr_locate","title":"Find patterns in expressions — expr_match","text":"shortcut functions return information given expr_match, often convenient format. expr_count returns integer vector one element every expression expr, element giving number matches pattern found. expr_detect returns logical vector one element every expression expr, element giving whether least one match pattern found. expr_extract returns, expression expr, list complete matches. , specifing capture token name argument , can extracted instead. example:   gives list(list(quote(), quote(x)), NULL, list(3)). Using gather = TRUE expr_extract returns succesful matches single, unnested list; call expr_extract gather = TRUE give list(quote(), quote(x), 3). Finally, expr_locate similar expr_extract returns location within expr successful match.","code":"expr_extract(expr_list({(a+b)+(x+y)},     {\"H\"*\"I\"}, {3+4}), {.A + .B}, \"A\")"},{"path":[]},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find patterns in expressions — expr_match","text":"","code":"expr_match({ 1 + 2 }, { .A + .B }) #> expr_match: list( #>   list(match = quote(1 + 2), loc = NULL, A = 1, B = 2) #> )  # match to one of several alternatives expr_match({ 5 - 1 }, { .A + .B } ? { .A - .B }) #> expr_match: list( #>   list(alt = 2L, match = quote(5 - 1), loc = NULL, A = 5, B = 1) #> )"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_replace.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace patterns within expressions — expr_replace","title":"Replace patterns within expressions — expr_replace","text":"Match replace elements patterns expression list expressions.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_replace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace patterns within expressions — expr_replace","text":"","code":"expr_replace(expr, ..., patterns, replacements,     n = Inf, env = parent.frame())"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_replace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace patterns within expressions — expr_replace","text":"expr Input. expression, expr_list, list() expressions. Also works formulas lists formulas. ... Alternating series patterns replacements, single expression (though alternatives can specified ?). patterns Patterns look . expression, expr_list, list() expressions. replacements Replacements, one pattern. n Maximum number times expression make replacement; default Inf. env Environment injections expr, pattern (see expression).","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_replace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace patterns within expressions — expr_replace","text":"input expression(s) replacements made.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_replace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Replace patterns within expressions — expr_replace","text":"Patterns follow syntax expr_match().","code":""},{"path":[]},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_replace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace patterns within expressions — expr_replace","text":"","code":"# Example with alternating patterns and replacements expr_replace({ 1 + 2 }, {1}, {one}, {2}, {two}) #> one + two  # Example with patterns and replacements in a list expr_replace({ 1 + 2 }, patterns = expr_list({1}, {2}),     replacements = expr_list({one}, {two})) #> one + two  # Replace with captures expr_replace({ 1 + 2 }, ~{ .A + .B }, { .A - .B }) #> 1 - 2"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set a subexpression — expr_sub","title":"Get or set a subexpression — expr_sub","text":"functions allow extract /modify subexpression within expression.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set a subexpression — expr_sub","text":"","code":"expr_sub(expr, idx, env = parent.frame())  expr_sub(expr, idx, env = parent.frame()) <- value"},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_sub.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set a subexpression — expr_sub","text":"expr expression select . Can also list expressions, case first element index selects expression list. Can also formula. idx valid index: NULL integer vector. env Environment injections expr (see expression). value Replacement; expression.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set a subexpression — expr_sub","text":"element expression selected idx.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_sub.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get or set a subexpression — expr_sub","text":"elixir functions expr_match() expr_locate() find matching \"subexpressions\" within expressions return indices allow accessing subexpressions. example, expression 1 + 2 + 3 contains following subexpressions: index returned expr_match() expr_locate() either NULL (meaning whole expression / expression list) integer vector (e.g. 1 c(2,3) table ). Suppose index, idx. idx integer vector, can just use expr[[idx]] access subexpression. case idx NULL, R complain trying select less one element. sole purpose expr_sub() get around issue allow pass either NULL integer vector index want expression list expressions.","code":""},{"path":[]},{"path":"https://nicholasdavies.github.io/elixir/reference/expr_sub.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set a subexpression — expr_sub","text":"","code":"expr = quote(y == a * x + b) expr_sub(expr, NULL) #> y == a * x + b expr_sub(expr, 3) #> a * x + b expr_sub(expr, c(3, 3)) #> b  expr_sub(expr, c(3, 3)) <- quote(q) print(expr) #> y == a * x + q"},{"path":"https://nicholasdavies.github.io/elixir/reference/lang2str.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an expression into a string — lang2str","title":"Convert an expression into a string — lang2str","text":"opposite str2lang(), lang2str() converts expression character string. Note lang2str() support normal expression syntax elixir, just expects already-parsed expression.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/lang2str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an expression into a string — lang2str","text":"","code":"lang2str(x)"},{"path":"https://nicholasdavies.github.io/elixir/reference/lang2str.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an expression into a string — lang2str","text":"x Expression convert string.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/lang2str.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an expression into a string — lang2str","text":"character string suitable printing.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/lang2str.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert an expression into a string — lang2str","text":"function essentially identical deparse1(), available since R 4.0.0, except collapse = \"\" instead collapse = \" \".","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/lang2str.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an expression into a string — lang2str","text":"","code":"lang2str(quote(a + b + c)) #> [1] \"a + b + c\""},{"path":"https://nicholasdavies.github.io/elixir/reference/meld.html","id":null,"dir":"Reference","previous_headings":"","what":"Code generation from template file — meld","title":"Code generation from template file — meld","text":"meld reads specially-formatted file filename file lines text passed via unnamed arguments returns lines text performing substitutions R code. function experimental.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/meld.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Code generation from template file — meld","text":"","code":"meld(   ...,   file = NULL,   rules = NULL,   reindent = TRUE,   ipath = \".\",   env = rlang::env_clone(parent.frame()) )"},{"path":"https://nicholasdavies.github.io/elixir/reference/meld.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Code generation from template file — meld","text":"... Lines interpreted text. embedded newlines line, line split multiple lines. file File read text. rules rules follow. can pass string among \"C\", \"C++\", \"Lua\", \"R\", list elements: comment Character vector comments (used backticked lines skipped); either NA comments, one string end--line comments two strings delimited comments. indent_more Character vector tokens increase indent level. indent_less Character vector tokens decrease indent level. indent_both Character vector tokens decrease, increase indent level (see reindent()). ignore Comment string literal delimiters (see reindent()). NULL, default, either guess rules file extension, possible, put 'skipped' comments reindent result. NA try guess. reindent TRUE, default, reindent according rules. FALSE, reindent. ipath Path search #included files env Environment evaluate R expressions. default rlang::env_clone(parent.frame()), best clone environment new declarations pollute environment question.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/meld.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Code generation from template file — meld","text":"interpreted text single character string.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/meld.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Code generation from template file — meld","text":"meld works line text, blocks text starting delimiter /***R ending */ run R code. Outside blocks, substrings text delimited `backticks` interpreted R expressions substituted line. backticked expressions length 0, line commented (message \"[skipped]\" appended) using comment element rules. backticked expressions length L > 1, entire interpreted line repeated L times, separated newlines elements expression sequence. special sequences: `^expr` subs expr first line multi-line expansion `!^expr` subs expr first line multi-line expansion `$expr`subs expr last line multi-line expansion `!$expr` subs expr last line multi-line expansion `#include file` interprets file R expression resolving filename, runs file meld, pastes result #include command must appear line, searches files path ipath. function tries guess rules file extension possible. file extension .c, \"C\" guessed; .h, .hpp, .cpp, \"C++\" guessed; .R, \"R\" guessed; .lua, \"Lua\" guessed. Case ignored file extensions. R blocks evaluated immediately prior next-occurring backticked line, variables modified R block available backticked expression following R block. remaining R blocks run remaining lines interpreted. line text ends single backslash \\, next line concatenated . line text ends double backslash \\\\, next line concatenated newline separator. allows backticked expressions apply multiple lines.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/meld.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Code generation from template file — meld","text":"","code":"meld(     \"/***R\",     \"names = c('a', 'b', 'c');\",     \"dontdothis = NULL;\",     \"*/\",     \"double foo()\",     \"{\",     \"    double `names` = `1:3`;\",     \"    double `dontdothis` = this_doesnt_matter;\",     \"    return `paste(names, collapse = ' + ')`;\",     \"}\") #> [1] \"double foo()\\n{\\n    double a = 1;\\n    double b = 2;\\n    double c = 3;\\n    return a + b + c;\\n}\""},{"path":"https://nicholasdavies.github.io/elixir/reference/reindent.html","id":null,"dir":"Reference","previous_headings":"","what":"Reindent some lines of code — reindent","title":"Reindent some lines of code — reindent","text":"Using fairly unsophisticated metrics, reindent() take lines code , according understanding rules language, reindent lines. intended help prettify automatically generated code. function experimental.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/reindent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reindent some lines of code — reindent","text":"","code":"reindent(lines, rules, tab = \"    \", start = 0L)"},{"path":"https://nicholasdavies.github.io/elixir/reference/reindent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reindent some lines of code — reindent","text":"lines Character vector lines text; can internal newlines. rules rules follow. can pass string among \"C\", \"C++\", \"Lua\", \"R\", list elements: indent_more Character vector tokens increase indent level. indent_less Character vector tokens decrease indent level. indent_both Character vector tokens decrease, increase indent level (see Details). ignore Comment string literal delimiters (see Details). tab Character string; use indent. start Indent level start .","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/reindent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reindent some lines of code — reindent","text":"Reindented lines character vector.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/reindent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reindent some lines of code — reindent","text":"Conceptually, function first ignores comments string literals. , line line, reindent looks tokens signal either increase indent level, decrease indent level, time. example, Lua code:   keyword increases indent level, else keyword decreases increases indent level, end keyword decreases indent level. provided, ignore element rules list character vectors. character vector length one assumed start comment runs end line (e.g. \"#\" R). length two, two symbols assumed start end comment string (e.g. \"/*\" \"*/\" C). length three, first two symbols start end delimiters comment string, third symbol \"escape\" character escapes end delimiter (can also escape ). typically backslash. reindent() supports \"raw strings\" R, C, C++, Lua code limited cases. R, using raw character constants must use uppercase R, double quote symbol zero two hyphens. C/C++, using raw string literals must use prefix R, zero two hyphens delimiter char sequence (plus parentheses). Lua, can use long brackets zero two equals signs. attempt use raw strings probably break reindent(). unusual character sequences may also break reindent().","code":"if x == 1 then     print 'one' else     print 'not one' end"},{"path":"https://nicholasdavies.github.io/elixir/reference/reindent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reindent some lines of code — reindent","text":"","code":"reindent(     c(         \"if x == 1 then\",         \"print 'one'\",         \"else\",         \"print 'not one'\",         \"end\"     ),     rules = \"Lua\") #> [1] \"if x == 1 then\"      \"    print 'one'\"     \"else\"                #> [4] \"    print 'not one'\" \"end\""},{"path":"https://nicholasdavies.github.io/elixir/reference/subset-.expr_alt.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign to part of an expr_alt. — [<-.expr_alt","title":"Assign to part of an expr_alt. — [<-.expr_alt","text":"exists primarily expr_apply can applied expr_list, may potentially contain elements class expr_alt.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/subset-.expr_alt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign to part of an expr_alt. — [<-.expr_alt","text":"","code":"# S3 method for class 'expr_alt' xl[i] <- value"},{"path":"https://nicholasdavies.github.io/elixir/reference/subset-.expr_alt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign to part of an expr_alt. — [<-.expr_alt","text":"modified object class \"expr_alt\".","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/translate.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate an R expression — translate","title":"Translate an R expression — translate","text":"Takes R expression (sense rlang::is_expression()) translates character string giving equivalent expression another programming language, according supplied rules. function experimental.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/translate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate an R expression — translate","text":"","code":"translate(expr, rules, env = parent.frame())"},{"path":"https://nicholasdavies.github.io/elixir/reference/translate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate an R expression — translate","text":"expr Expression list expressions translated. rules rules follow. can pass string among \"C\", \"C++\", \"Lua\", \"R\", list translation rules (see Details). env Environment injections expr (see expression).","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/translate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate an R expression — translate","text":"translated expression single character string.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/translate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate an R expression — translate","text":"parameter rules can character string naming \"built-\" ruleset. Otherwise, rules list following elements: ops: unnamed list operator definitions, list four elements: arity number operands prec precedence operator (lower numbers equal higher precedence) assoc associativity operator, either \"LTR\", \"RTL\", anything else associativity str glue::glue() format string {[1]}, {[2]}, etc., standing first, second, etc. operands. nopar numeric vector indices arguments operator never enclosed parentheses. default usual value integer(0), (example) can 2 [ operator, parentheses within second argument (content brackets) redundant. function elixir:::op can help assemble lists. paren glue::glue() format string {x} standing enclosed expression. Describes parentheses expressed target language. Example: \"({x})\" correct virtually programming languages. symbol: function takes symbol returns character string, representing name symbol target language. just equal base::.character, can changed something else case want name mangling, e.g. processing replace . symbols character (. often allowed part symbols popular languages). literal: named list name refers class operand translate, value function single argument (operand) returning character string. may helpful inspect elixir:::ruleset clarify format. important shortcomings translate(). potential pitfalls: Named arguments supported, translate R function call like mean(x, na.rm = TRUE) without knowing parameter mean matches na.rm. Division: R expression like 1/3 gets translated 1./3. C/C++, numeric literals coerced type double. evaluate 0.333. However, R expression 1L/3L get translated 1/3 C/C++, evaluates 0 (integer division). Modulo: R uses \"Knuth's modulo\", %% b sign b. Lua also uses Knuth's modulo, C/C++ use \"truncated modulo\", % b sign . (see Wikipedia details). converting modulo expression R C/C++, call function kmod generated C/C++ expression. standard library function, provide definition . workable definition : double kmod(double x, double y) { double r = fmod(x, y); return r && r < 0 != y < 0 ? r + y : r; } Types: R, type %% b %/% b depends type b (integers, result integer; least one numeric, result numeric). Chained assignment work Lua.","code":""},{"path":"https://nicholasdavies.github.io/elixir/reference/translate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate an R expression — translate","text":"","code":"translate({x ^ y}, \"C++\") #> pow(x, y)"},{"path":"https://nicholasdavies.github.io/elixir/news/index.html","id":"elixir-011","dir":"Changelog","previous_headings":"","what":"elixir 0.1.1","title":"elixir 0.1.1","text":"CRAN release: 2025-12-02 elixir now works formulas. Removed dependencies data.table methods packages.","code":""},{"path":"https://nicholasdavies.github.io/elixir/news/index.html","id":"elixir-010","dir":"Changelog","previous_headings":"","what":"elixir 0.1.0","title":"elixir 0.1.0","text":"CRAN release: 2025-09-24 Initial CRAN submission.","code":""}]
